---
title: 国密算法
date: 2017-01-01 09:00:00
tags: [算法]
---

# SM3 杂凑算法（摘要算法）

> 对长度为 l（l < 2^64）比特的消息 m，经过填充和迭代压缩，生成 256 比特的杂凑值。

## 术语和定义

- ABCDEFGH：8 个字寄存器或它们的值的串联
- ∧：32 比特与运算
- ∨：32 比特或运算
- ⊕：32 比特异或运算
- ﹁：32 比特非运算
- +：mod2<sup>32</sup> 算数加运算
- <<<：循环左移
- CF：压缩函数（见 2.3 节）
- IV：压缩函数寄存器的初始值
    7380166f 4914b2b9 172442d7 da8a0600 a96f30bc 163138aa e38dee4d b0fb0e4e
- FF<sub>j</sub>：布尔函数，随 j 的变化取不同的表达式
$ FF_j(X,Y,Z)=\begin{cases} X \oplus Y \oplus Z, & 0 \le j \le 15 \\ (X \wedge Y)\vee(X \wedge Z)\vee(Y \wedge Z), & 16 \le j \le 63 \end{cases} $
- GG<sub>j</sub>：布尔函数，随 j 的变化取不同的表达式
$ GG_j(X,Y,Z)=\begin{cases} X \oplus Y \oplus Z, & 0 \le j \le 15 \\ (X \wedge Y)\vee(\neg X \wedge Z), & 16 \le j \le 63 \end{cases} $
- P<sub>0</sub>：压缩函数中的置换函数
$ P_0(X)=X \oplus (X \lll 9) \oplus (X \lll 17) $
- P<sub>1</sub>：消息扩展中的置换函数
$ P_1(X)=X \oplus (X \lll 15) \oplus (X \lll 23) $
- T<sub>j</sub>：常量，随 j 的变化取不同的值
$ T_j = \begin{cases} 79cc4519, & 0 \le j \le 15 \\ 7a879d8a, & 16 \le j \le 63 \end{cases} $



## 1. 填充

设消息 m 的长度为 l 比特。

1. 将比特值“1”添加到消息的末尾；
2. 再在末尾添加 k 个“0”，其中 k 是满足 *l + 1 + k = 448 mod 512* 的最小的非负整数；

    ```
    int k = 448 - (8 * inputStr.length + 1) % 512;
    if (k < 0) {
        k = k + 512;
    }
    ```
3. 再在末尾添加一个 64 位比特串，该比特串为 l 的二进制表示；
4. 填充后的消息 m' 的比特长度为 512 的倍数。

## 2. 迭代压缩

### 2.1 迭代过程

1. 将填充后的消息 m' 按 512 比特进行分组：
$m' = B^{(0)}B^{(1)}...B^{(n-1)}$
2. 对 m' 按以下方式迭代：
$ for\;i\;=\;0\;to\;n-1 $
$ \qquad V^{(i+1)} = CF(V^{(i)}, B^{(i)}) $
$ endfor $

### 2.2 消息扩展

将消息分组 B<sup>(i)</sup> 按以下方法扩展成 132 个字 W<sub>0</sub>,W<sub>1</sub>,...,W<sub>67</sub>，W'<sub>0</sub>,W'<sub>1</sub>,...,W'<sub>63</sub>，用于压缩函数 CF。

1. 将消息分组 B<sup>(i)</sup> 划分为 16 个字 W<sub>0</sub>,W<sub>1</sub>,...,W<sub>15</sub>
2. $ for\;j\;=\;16\;to\;67 \\
\qquad W_j \leftarrow P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-3} \lll 15)) \oplus (W_{j-13} \lll 7) \oplus W_{j-6} \\
endfor $
3. $ for\;j=0\;to\;63 \\
\qquad W'_j = W_j \oplus W_{j+4} \\
endfor $

### 2.3 压缩函数

令 A，B，C，D，E，F，G，H 为字寄存器，SS1，SS2，TT1，TT2 为中间变量，压缩函数
$ V^{i+1}=CF(V^{(i)},B^{(i)}), 0 \le i \le n-1 $
计算过程描述如下：

$ ABCDEFGH \leftarrow V^{(i)} \\
for\;j=0\;to\;63 \\
\qquad SS1 \leftarrow ((A \lll 12)+E+(T_j \lll j)) \lll 7 \\
\qquad SS2 \leftarrow SS1 \oplus (A \lll 12) \\
\qquad TT1 \leftarrow FF_j(A,B,C)+D+SS2+W'_j \\
\qquad TT2 \leftarrow GG_j(E,F,G)+H+SS1+W_j \\
\qquad D \leftarrow C \\
\qquad C \leftarrow B \lll 9 \\
\qquad B \leftarrow A \\
\qquad A \leftarrow TT1 \\
\qquad H \leftarrow G \\
\qquad G \leftarrow F \lll 19 \\
\qquad F \leftarrow E \\
\qquad E \leftarrow P_0(TT2) \\
endfor \\
V^{(i+1)} \leftarrow ABCDEFGH \oplus V^{(i)} $

其中，字的存储为大端（big-endian）格式。

## 3. 输出杂凑值

输出256比特的杂凑值y = ABCDEFGH = V<sup>(n)</sup>。

---
# Javascript 实现

```
// 入口
function sm3Digest(str) {
    var binary = str2binary(str);
    // 1. 填充
    var len = binary.length;
    // k 是满足 len + 1 + k = 448 mod 512 的最小非负整数
    var k = 448 - (len + 1) % 512;
    if (k < 0) {
        k = k + 512;
    }
    var m = "" + binary + "1" + leftPad('', k) + leftPad(len.toString(2), 64);
    // 2. 迭代压缩
    var n = (len + k + 65) / 512;
    var V = hex2binary('7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e');//初值
    for (var i = 0; i < n; i += 1) {
        var B = m.substr(512 * i, 512);
        V = compress(V, B);
    }
    return binary2hex(V);
}

// 左补0到指定长度
function leftPad(str, totalLength) {
    const len = str.length;
    return Array(totalLength > len ? ((totalLength - len) + 1) : 0).join(0) + str;
}

// 二进制转化为十六进制
function binary2hex(binary) {
    const binaryLength = 8;
    var hex = '';
    for (var i = 0; i < binary.length / binaryLength; i += 1) {
        hex += leftPad(parseInt(binary.substr(i * binaryLength, binaryLength), 2).toString(16), 2);
    }
    return hex;
}

// 十六进制转化为二进制
function hex2binary(hex) {
    const hexLength = 2;
    var binary = '';
    for (var i = 0; i < hex.length / hexLength; i += 1) {
        binary += leftPad(parseInt(hex.substr(i * hexLength, hexLength), 16).toString(2), 8);
    }
    return binary;
}

// 普通字符串转化为二进制
function str2binary(str) {
    var binary = '';
    for (var i = 0; i < str.length; i += 1) {
        binary += leftPad(str.charCodeAt(i).toString(2), 8);
    }
    return binary;
}

// 循环左移
function rol(str, n) {
    if (str === undefined) {
        window.alert("str is undefined")
    }
    return str.substr(n % str.length) + str.substr(0, n % str.length);
}

// 二进制运算
function binaryCal(x, y, method) {
    const a = x || '';
    const b = y || '';
    const result = [];
    var prevResult;
    // for (let i = 0; i < a.length; i += 1) { // 小端
    for (var i = a.length - 1; i >= 0; i -= 1) { // 大端
        prevResult = method(a[i], b[i], prevResult);
        result[i] = prevResult[0];
    }
    // console.log(`x     :${x}\ny     :${y}\nresult:${result.join('')}\n`);
    return result.join('');
}

// 二进制异或运算
function xor(x, y) {
    return binaryCal(x, y, function (a, b) {
        return [a === b ? '0' : '1'];
    });
}

// 二进制与运算
function and(x, y) {
    return binaryCal(x, y, function (a, b) {
        return [a === '1' && b === '1' ? '1' : '0'];
    });
}

// 二进制或运算
function or(x, y) {
    return binaryCal(x, y, function (a, b) {
        return [a === '1' || b === '1' ? '1' : '0'];
    });
}

/**
 * 二进制加运算
 * @return [result, carry]
 */
function add(x, y) {
    return binaryCal(x, y, function (a, b, prevResult) {
        var carry = prevResult ? prevResult[1] : '0';//进位
        if (a !== b) {
            return [carry === '0' ? '1' : '0', carry];//a !== b 时，进位位不变，a + b 与 进位位相反
        } else {
            return [carry, a];//a === b 时，a + b === 原 carry，新 carry === a === b
        }
    });
}

/**
 * 二进制非运算
 */
function not(x) {
    //return binaryCal(x, undefined, a => [a === '1' ? '0' : '1']);
    return binaryCal(x, undefined, function (a) {
        return [a === '1' ? '0' : '1'];
    });
}

/**
 * 调用不同的 Array.reduce() 函数
 * @param method
 * @return {Function}
 */
function calMulti(method) {
    return function () {
        return Array.prototype.slice.apply(arguments).reduce(method)
    };
}

// 压缩函数中的置换函数 P0(X) = X xor (X <<< 9) xor (X <<< 17)
function P0(X) {
    return calMulti(xor)(X, rol(X, 9), rol(X, 17));
}

// 消息扩展中的置换函数 P1(X) = X xor (X <<< 15) xor (X <<< 23)
function P1(X) {
    return calMulti(xor)(X, rol(X, 15), rol(X, 23));
}

// 布尔函数，随j的变化取不同的表达式
function FF(X, Y, Z, j) {
    return j >= 0 && j <= 15 ? calMulti(xor)(X, Y, Z) : calMulti(or)(and(X, Y), and(X, Z), and(Y, Z));
}

// 布尔函数，随j的变化取不同的表达式
function GG(X, Y, Z, j) {
    return j >= 0 && j <= 15 ? calMulti(xor)(X, Y, Z) : or(and(X, Y), and(not(X), Z));
}

// 常量，随j的变化取不同的值
function T(j) {
    return j >= 0 && j <= 15 ? hex2binary('79cc4519') : hex2binary('7a879d8a');
}

// 压缩函数
function compress(V, Bi) {
    // 消息扩展
    const wordLength = 32;
    const W = [];
    const M = [];// W'

    // 将消息分组B划分为16个字W0， W1，…… ，W15 （字为长度为32的比特串）
    for (var i = 0; i < 16; i += 1) {
        W.push(Bi.substr(i * wordLength, wordLength));
    }

    // W[j] <- P1(W[j−16] xor W[j−9] xor (W[j−3] <<< 15)) xor (W[j−13] <<< 7) xor W[j−6]
    for (var j = 16; j < 68; j += 1) {
        W.push(calMulti(xor)(
            P1(calMulti(xor)(W[j - 16], W[j - 9], rol(W[j - 3], 15))),
            rol(W[j - 13], 7),
            W[j - 6]
        ));
    }

    // W′[j] = W[j] xor W[j+4]
    for (var j = 0; j < 64; j += 1) {
        M.push(xor(W[j], W[j + 4]));
    }

    // 压缩
    const wordRegister = [];// 字寄存器
    for (var j = 0; j < 8; j += 1) {
        wordRegister.push(V.substr(j * wordLength, wordLength));
    }

    var A = wordRegister[0];
    var B = wordRegister[1];
    var C = wordRegister[2];
    var D = wordRegister[3];
    var E = wordRegister[4];
    var F = wordRegister[5];
    var G = wordRegister[6];
    var H = wordRegister[7];

    // 中间变量
    var SS1;
    var SS2;
    var TT1;
    var TT2;
    for (var j = 0; j < 64; j += 1) {
        SS1 = rol(calMulti(add)(rol(A, 12), E, rol(T(j), j)), 7);
        SS2 = xor(SS1, rol(A, 12));

        TT1 = calMulti(add)(FF(A, B, C, j), D, SS2, M[j]);
        TT2 = calMulti(add)(GG(E, F, G, j), H, SS1, W[j]);

        D = C;
        C = rol(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = rol(F, 19);
        F = E;
        E = P0(TT2);
    }

    return xor(Array(A, B, C, D, E, F, G, H).join(''), V);
}
```

---
# custom

```
function sm3Digest(str) {
    //1. 转换为二进制数组
    var binArr = str2bin(str2rstr_utf8(str));
    //2. 填充
    var groupNum = alignSM3(binArr, str.length);
    //3. 迭代压缩
    var v = new Array(8);//初始值
    v[0] = 0x7380166f;
    v[1] = 0x4914b2b9;
    v[2] = 0x172442d7;
    v[3] = 0xda8a0600;
    v[4] = 0xa96f30bc;
    v[5] = 0x163138aa;
    v[6] = 0xe38dee4d;
    v[7] = 0xb0fb0e4e;
    //按 512bit 分组进行压缩
    for (var i = 0; i < groupNum; i++) {
        v = compress(v, binArr, i);
    }
    return word2str(v, ' ');
}

function word2str(words, seperator) {
    var prefix = Array(8).join('0');
    for (var i = 0; i < words.length; i++) {
        //若 hex 不足 8 位，则高位补 0
        words[i] = (prefix + (words[i] >>> 0).toString(16)).slice(-8);
    }

    return words.join(seperator);
}

/**
 * 将字符串转换为二进制数组，默认字符串编码为 UTF-8，且范围在 0x00~0xFF 内。
 * 若某些字符的编码超过此范围，则会只保留低二字节。加密可正常进行，但加密结果有误。
 * 每个数组元素包含 4 个字符，即 32 bit。
 */
function str2bin(str) {
    var binary = new Array(str.length >> 2);
    for (var i = 0; i < str.length * 8; i += 8) {
        binary[i >> 5] |= (str.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
    }
    return binary;
}

/**
 * 对明文的二进制串进行填充
 * 
 * |  满足 mod 512 = 448 |           固定 64 位         |
 * | 明文二进制 |填充部分|明文二进制串的长度的二进制表示|
 *  xxxxxxxxxxxx 10.....0 0...........................xx
 */
function alignSM3(arr, strLen) {
    //在明文二进制串后面拼接 1000 0000
    arr[strLen >> 2] |= 0x80 << (24 - strLen % 4 * 8);
    var groupNum = ((strLen + 8) >> 6) + 1;//以 512bit 为一组，总的组数
    var wordNum = groupNum * 16;//一个 word 32bit，总的 word 数

    for (var i = (strLen >> 2) + 1; i < wordNum; i++) {
        arr[i] = 0;
    }
    arr[wordNum - 1] = strLen * 8;//在末尾填上明文的二进制长度

    return groupNum;
}

/**
 * 压缩函数中的置换函数
 */
function permutate0(x) {
    return x ^ bitRol(x, 9) ^ bitRol(x, 17);
}

/**
 * 压缩函数中的置换函数
 */
function permutate1(x) {
    return x ^ bitRol(x, 15) ^ bitRol(x, 23);
}

/**
 * 循环左移
 */
function bitRol(input, n) {
    return (input << n) | (input >>> (32 - n));
}

/**
 * 压缩函数
 */
function compress(v, binArr, i) {
    //将消息分组扩展成 132 个字
    var w1 = new Array(68);
    var w2 = new Array(64);
    for (var j = 0; j < 68; j++) {
        if (j < 16) {
            w1[j] = binArr[i * 16 + j];
        } else {
            w1[j] = permutate1(w1[j-16] ^ w1[j-9] ^ bitRol(w1[j-3], 15)) ^ bitRol(w1[j-13], 7) ^ w1[j-6];
        }
    }
    for (var j = 0; j < 64; j++) {
        w2[j] = w1[j] ^ w1[j+4];
    }

    //压缩
    var a = v[0];
    var b = v[1];
    var c = v[2];
    var d = v[3];
    var e = v[4];
    var f = v[5];
    var g = v[6];
    var h = v[7];
    var ss1;
    var ss2;
    var tt1;
    var tt2;
    for (var j = 0; j < 64; j++) {
        ss1 = bitRol(add(bitRol(a, 12) , e , bitRol(t(j), j)), 7);
        ss2 = ss1 ^ bitRol(a, 12);
        tt1 = add(ff(a, b, c, j) , d , ss2 , w2[j]);
        tt2 = add(gg(e, f, g, j) , h , ss1 , w1[j]);
        d = c;
        c = bitRol(b, 9);
        b = a;
        a = tt1;
        h = g;
        g = bitRol(f, 19);
        f = e;
        e = permutate0(tt2);
    }
    v[0] ^= a;
    v[1] ^= b;
    v[2] ^= c;
    v[3] ^= d;
    v[4] ^= e;
    v[5] ^= f;
    v[6] ^= g;
    v[7] ^= h;
    return v;
}

/**
 * 常量 T 随 j 的不同而不同
 */
function t(j) {
    if (0 <= j && j < 16) {
        return 0x79CC4519;
    } else if (j < 64) {
        return 0x7A879D8A;
    }
}

/**
 * 布尔函数，随 j 的变化取不同的表达式
 */
function ff(x, y, z, j) {
    if (0 <= j && j < 16) {
        return x ^ y ^ z;
    } else if (j < 64) {
        return (x & y) | (x & z) | (y & z);
    }
}

/**
 * 布尔函数，随 j 的变化取不同的表达式
 */
function gg(x, y, z, j) {
    if (0 <= j && j < 16) {
        return x ^ y ^ z;
    } else if (j < 64) {
        return (x & y) | (~x & z);
    }
}

/**
 * 避免某些 js 引擎的 32 位加法的 bug
 */
function safe_add(x, y) {
  var lsw = ( x & 0xFFFF ) + (y & 0xFFFF);
  var msw = ( x >> 16 ) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | ( lsw & 0xFFFF );
}

/**
 * 将所有参数相加
 */
function add() {
    var sum = 0;
    for (var i = 0; i < arguments.length; i++) {
        sum = safe_add(sum, arguments[i]);
    }
    return sum;
}

function test_sm3Digest() {
    return "52af3ad47de06699f242e35171c56387e01b806906aec5395776019a289622b1"==sm3Digest("abc123");
}

function str2rstr_utf8(input) {
  var output = "" ;
  var i = -1 ;
  var x, y ;

  while(++ i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input .charCodeAt (i + 1) : 0 ;
    if( 0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF )
    {
      x = 0x10000 + ((x & 0x03FF) << 10 ) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if( x <= 0x7F )
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F ));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F ),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F ));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07 ),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F ));
  }
  return output;
}
```

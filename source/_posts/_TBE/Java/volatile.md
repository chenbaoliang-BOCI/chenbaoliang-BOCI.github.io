---
title: volatile
date: 2017-01-01 09:00:00
tags: [Java]
---

*本文内容摘取及参考自[此博客](http://www.cnblogs.com/dolphin0520/p/3920373.html)*

# 硬件层面的并发同步问题

CPU 处理数据时，先将内存中的数据读取到高速缓存中，处理结束之后将高速缓存中的数据写回到内存中。

这种数据处理方式提高了速度，但会引起并发同步问题。即使是单核 CPU，也会以线程调度的形式表现出该问题。

为解决缓存不一致问题，通常有 2 种解决方法：

- 在总线加 LOCK# 锁；
- 通过缓存一致性协议。

在早期的 CPU 中，是通过在总线上加 LOCK# 锁的方式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。但是由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。

所以就出现了缓存一致性协议。最出名的就是 Intel 的 MESI 协议。MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

---
# 并发编程涉及到的 3 个概念及 Java 提供的方案

在 Java 虚拟机规范中通过定义一种 Java 内存模型（Java Memory Model，JMM）试图来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。

注意，为了获得较好的执行性能，Java 内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，**在 Java 内存模型中，也会存在缓存一致性问题和指令重排序的问题**。

Java 内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

## 1. 原子性

> 原子性指的是操作的不可拆解性。具有原子性的操作要么全部执行，要么全部不执行，无法拆解开一步步地执行。

在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。如果要实现更大范围操作的原子性，可以通过 `synchronized` 和 `Lock` 来实现。
在低版本 JDK 中，在 32 位平台下，对 64 位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的 JDK 中，JVM 已经保证对 64 位数据的读取和赋值也是原子性操作了。

## 2. 可见性

> 可见性指的是当多线程访问同一变量时，若某一线程更改了该变量，则其他线程能立即获知该变量已被修改，并去读取最新的值。

对于可见性，Java 提供了 `volatile` 关键字来保证可见性。当一个共享变量被 `volatile` 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，会去主存中读取新值。

而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过 `synchronized` 和 `Lock` 也能够保证可见性，`synchronized` 和 `Lock` 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

## 3. 有序性

> 有序性指的是程序按照源代码的编写顺序执行。

在 Java 内存模型中，允许编译器和处理器对指令进行重排序（Instruction Reorder），但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

在 Java 里面，可以通过 volatile 关键字来保证一定的“有序性”。另外可以通过 `synchronized` 和 `Lock` 来保证有序性，很显然，`synchronized` 和 `Lock` 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

另外，Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 “**happens-before**” 原则。如果两个操作的执行次序无法从“happens-before”原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

**happens-before** 原则（先行发生原则）：

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。（这条实际上指的是编译器的指令重排一定不会影响单线程状态下的正确性，即对于单线程来说，程序就像是按照代码顺序执行的一样）
- 锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作
- volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C
- 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作
- 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始

---
# 深入剖析 volatile

## volatile 的两层语义

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序。

## volatile 是否保证原子性

volatile 不保证原子性。可用 synchronized、Lock、java.util.concurrent.atomic.* 来保证原子性

## volatile 是否保证可见性

1. 使用 volatile 关键字会强制将修改的值立即写入主存；
2. 使用 volatile 关键字的话，当线程 2 修改某共享变量时，会导致线程 1 的工作内存中的该变量的缓存行无效（反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）；
3. 由于线程 1 的工作内存中的缓存变量的缓存行无效，所以线程 1 再次读取变量的值时会去主存读取。

## volatile 是否保证有序性

volatile 关键字禁止指令重排序有两层意思：

1. 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
2. 在进行指令优化时，不能将在对 volatile 变量访问的语句前面的语句放在其后面执行，也不能把在对 volatile 变量访问的语句后面的语句放到其前面执行。

## volatile 的原理和实现机制

“观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令”——《深入理解Java虚拟机》

lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

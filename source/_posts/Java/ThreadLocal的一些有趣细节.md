---
title: ThreadLocal的一些有趣细节
date: 2018-07-25 19:15:31
tags: [Java]
---

# 设计思路

ThreadLocal 的设计初看其实是反直觉的。

要设计一种将业务对象与线程绑定的方法，我脑海中蹦出的第一个方案就是在每个 ThreadLocal 实例中维护一个 Map，以 Thread 为键，以业务对象为值。

而实际上 ThreadLocal 的设计思路是：在每个 Thread 实例中维护一个 Map，以 ThreadLocal 为键，以业务对象为值。

两种思路截然相反。实际上重要的不是为什么采用后者，而是为什么不采用前者。

因为前者方案有一个重要缺陷：

既然是将业务对象与线程绑定，那么当线程本身被回收时自然应该取消该线程对所有绑定对象的引用。前者方案要解决这个问题的话无非就是轮询每个线程的状态或者让线程回收时通知自己，显然都不行。后者方案直接将 Map 绑定在线程实例上，从而非常自然地解决了这个问题。

其实后者方案也有一个类似的缺陷：

虽然技术上 ThreadLocal 是一个将业务对象与线程绑定的容器，但这一点对于业务代码来说应该是透明的。换句话说，当业务代码将指向 ThreadLocal 的引用取消后，就应该认为业务代码的实际目的是取消对业务对象的引用。后者方案可以很自然地实现这点，而前者方案则不能。

很显然两种缺陷是对称的。其中的核心是：业务对象的生命周期应该取 Thread 和 ThreadLocal 两者的较短者，而两者的生命周期互相独立，所以必选其一。我猜测最终选择当前这种方案的理由是，TheadLocal 通常是被声明成一个 static 成员来使用的，生命周期贯穿应用的生命周期，比线程更长，所以绑定到线程上。

反例场景是很明显的：线程池中的线程可以是贯穿整个应用生命周期的，而 ThreadLocal 也完全可以被业务代码置 null。ThreadLocal 的设计者为了避免在这类场景下出现内存泄露，一方面在它的多个方法中搜索无效的 ThreadLocal 实例（通过弱引用实现）并清空相应的业务对象引用，另一方面强调业务代码要手动调用 remove 方法。

# ThreadLocalMap 的实现

ThreadLocalMap 是一种散列表，通过线性探查法解决哈希冲突。

线性探查法有两个主要的问题：

1. 若散列程度不够，那么局部会有大量元素聚积。
2. 对于哈希冲突的元素会紧挨着依次向后罗列。所以当删除其中某个元素时，要将后面的所有元素前移。

解决这两个问题的关键在于要有个优秀的散列算法。

ThreadLocal 产生哈希值的方法是反复对 0x61C88647 进行累加。源码中的注释是：

> turns implicit sequential thread-local IDs into near-optimally spread multiplicative hash values for power-of-two-sized tables

也就是说 0x61C88647 这个魔数在 2 的次方大小的空间内具有“接近完美”的哈希程度。

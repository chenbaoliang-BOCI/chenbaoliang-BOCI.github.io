---
title: JVM特性
date: 2018-03-19
tags: [Java]
---

部分内容摘录、整理自《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》。

# 内存管理



## 运行时数据区域

### 线程隔离的数据区

**程序计数器 Program Counter Register**

当前线程所执行的字节码的行号指示器。如果正在执行的是 native 方法，则计数器值为空。

**Java 虚拟机栈 Java Virtual Machine Stacks**

每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

一般所说的“栈”指的是其中的局部变量表。局部变量表存放了编译器可知的各种基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，运行期不会更改。

**本地方法栈 Native Method Stack**

与虚拟机栈类似，只不过是给本地方法使用的。本地方法栈中的语言、使用方式和数据结构没有强制规定。某些虚拟机甚至直接把虚拟机栈和本地方法栈合二为一。

### 线程共享的数据区

**Java 堆**

几乎所有对象实例都分配在堆上。

从内存回收的角度来说，可细分为新生代、老年代。再细分可分为 Eden 空间、From Survivor 空间、To Survivor 空间等。

从内存分配的角度来说，可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。

**方法区 Method Area**

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

由于 HotSpot VM 的设计团队把 GC 分代收集扩展到方法区，所以方法区也被称为“永生代”。但在其他虚拟机上是没有“永生代”的概念的。

**运行时常量池 Runtime Constant Pool**

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这部分内容在类加载后进入运行时常量池。但是运行期的常量也可以放到运行时常量池，比如 String.intern()。

### 其他

**直接内存 Directory Memory**

JDK 1.4 中加入的 NIO 类引入了一种基于通道和缓冲区的 I/O 方式，可以使用 native 函数库直接分配堆外内存，然后通过通过一个存储在堆中的 DirectoryByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据的消耗。

### 指定区域大小的参数

`-Xms123m` 堆初始容量。

`-Xmx123m` 堆最大容量。

`-XX:PermSize` 方法区初始容量。

`-XX:MaxPermSize` 方法区最大容量。

`-XX:MaxDirectMemorySize` 直接内存。默认与堆最大容量一致。

# 垃圾收集器与内存分配策略

## 几种对象判活算法

### 引用计数法

每个对象上保存一个引用计数器。

优点：实现简单，效率高。

缺点：难以解决对象之间循环引用的问题。

### 可达性分析算法

从一系列称为“GC Roots”的对象起始搜索，走过的路径称为引用链。若某个对象不在任何一条引用链上，则判为不可达。

可作为 GC Roots 的对象包括：

- 虚拟机栈中本地变量表里引用的对象；
- 本地方法栈中 native 方法引用的对象。
- 方法区中类静态变量属性引用的对象；
- 方法区中常量引用的对象。

回收流程：

1. 可达性分析后，发现对象没有引用链与 GC Roots 相连。对象被第一次标记并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。以下情况视为“没必要执行”：
   - 对象没有覆盖 finalize()；
   - finalize() 已被虚拟机调用过；
2. 若判定为有必要执行 finalize() ，那么此对象会被放置在 F-Queue 队列中，稍后由一个由虚拟机建立的、低优先级的线程去执行。虚拟机只会触发 finalize() 方法，但不承诺会等它执行完成（防止执行太慢或卡死导致队列中其他成员得不到执行）；
3. 稍后 GC 对 F-Queue 队列中的对象进行第二次标记，若仍没有与 GC Roots 相连，则基本上被确定为即将回收。

## 几种引用类型

Jdk 1.2 之后，Java 扩充了引用的类型。

- 强引用：即一般使用的引用，形如 `Object o = new Object()`，GC 永远不会回收强引用的对象。
- 软引用：通过 `SoftReference<T>` 来引用。即将发生 OOM 之前会把软引用的对象列入回收范围之内进行第二次回收。若第二次回收之后仍 OOM，才会抛出异常。
- 弱引用：通过 `WeakReference<T>` 来引用。弱引用只能存活到下次 GC 之前，不论内存是否足够。
- 虚引用：通过 `PhantomReference<T>` 来引用。虚引用对于对象的生存时间没有影响，也无法通过虚引用来获取对象实例。虚引用的唯一目的是在对象被回收时收到一个系统通知。

## 回收方法区

回收废弃常量与回收堆中对象类似。

判断一个类是“无用的类”需满足 3 个条件：

- 该类的所有实例都已回收；
- 加载该类的 ClassLoader 已被回收；
- 该类的 java.lang.Class 对象没有在任何地方被引用；

满足上述条件后“可以”进行回收，但“不一定”进行回收。

## 垃圾回收算法

### 标记-清除法


---
title: JVM特性
date: 2018-03-19
tags: [Java]
---

部分内容摘录、整理自《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》。

# 内存管理



## 运行时数据区域

### 线程隔离的数据区

**程序计数器 Program Counter Register**

当前线程所执行的字节码的行号指示器。如果正在执行的是 native 方法，则计数器值为空。

**Java 虚拟机栈 Java Virtual Machine Stacks**

每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

一般所说的“栈”指的是其中的局部变量表。局部变量表存放了编译器可知的各种基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，运行期不会更改。

**本地方法栈 Native Method Stack**

与虚拟机栈类似，只不过是给本地方法使用的。本地方法栈中的语言、使用方式和数据结构没有强制规定。某些虚拟机甚至直接把虚拟机栈和本地方法栈合二为一。

<!-- more -->

### 线程共享的数据区

**Java 堆**

几乎所有对象实例都分配在堆上。

从内存回收的角度来说，可细分为新生代、老年代。再细分可分为 Eden 空间、From Survivor 空间、To Survivor 空间等。

从内存分配的角度来说，可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。

**方法区 Method Area**

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

由于 HotSpot VM 的设计团队把 GC 分代收集扩展到方法区，所以方法区也被称为“永生代”。但在其他虚拟机上是没有“永生代”的概念的。

**运行时常量池 Runtime Constant Pool**

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这部分内容在类加载后进入运行时常量池。但是运行期的常量也可以放到运行时常量池，比如 String.intern()。

**元空间 Meta Space**

Java 8 中方法区已被废除，取而代之的是元空间。元空间使用本地内存，空间大小仅受可申请的系统内存限制。原先方法区中的字符串常量池和静态变量被移到了堆中。

### 其他

**直接内存 Directory Memory**

JDK 1.4 中加入的 NIO 类引入了一种基于通道和缓冲区的 I/O 方式，可以使用 native 函数库直接分配堆外内存，然后通过通过一个存储在堆中的 DirectoryByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据的消耗。

### 指定区域大小的参数

`-Xms123m` 堆初始容量。

`-Xmx123m` 堆最大容量。

`-XX:PermSize` 方法区初始容量。

`-XX:MaxPermSize` 方法区最大容量。

`-XX:MaxDirectMemorySize` 直接内存。默认与堆最大容量一致。

`-XX:MaxTenuringThreshold` 晋升到老年代的年龄阈值。

# 垃圾收集器与内存分配策略

## 几种对象判活算法

### 引用计数法

每个对象上保存一个引用计数器。

优点：实现简单，效率高。

缺点：难以解决对象之间循环引用的问题。

### 可达性分析算法

从一系列称为“GC Roots”的对象起始搜索，走过的路径称为引用链。若某个对象不在任何一条引用链上，则判为不可达。

可作为 GC Roots 的对象包括：

- 虚拟机栈中本地变量表里引用的对象；
- 本地方法栈中 native 方法引用的对象。
- 方法区中类静态变量属性引用的对象；
- 方法区中常量引用的对象。

回收流程：

1. 可达性分析后，发现对象没有引用链与 GC Roots 相连。对象被第一次标记并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。以下情况视为“没必要执行”：
   - 对象没有覆盖 finalize()；
   - finalize() 已被虚拟机调用过；
2. 若判定为有必要执行 finalize() ，那么此对象会被放置在 F-Queue 队列中，稍后由一个由虚拟机建立的、低优先级的线程去执行。虚拟机只会触发 finalize() 方法，但不承诺会等它执行完成（防止执行太慢或卡死导致队列中其他成员得不到执行）；
3. 稍后 GC 对 F-Queue 队列中的对象进行第二次标记，若仍没有与 GC Roots 相连，则基本上被确定为即将回收。

## 几种引用类型

Jdk 1.2 之后，Java 扩充了引用的类型。

- 强引用：即一般使用的引用，形如 `Object o = new Object()`，GC 永远不会回收强引用的对象。
- 软引用：通过 `SoftReference<T>` 来引用。即将发生 OOM 之前会把软引用的对象列入回收范围之内进行第二次回收。若第二次回收之后仍 OOM，才会抛出异常。
- 弱引用：通过 `WeakReference<T>` 来引用。弱引用只能存活到下次 GC 之前，不论内存是否足够。
- 虚引用：通过 `PhantomReference<T>` 来引用。虚引用对于对象的生存时间没有影响，也无法通过虚引用来获取对象实例。虚引用的唯一目的是在对象被回收时收到一个系统通知。

## 回收方法区

回收废弃常量与回收堆中对象类似。

判断一个类是“无用的类”需满足 3 个条件：

- 该类的所有实例都已回收；
- 加载该类的 ClassLoader 已被回收；
- 该类的 java.lang.Class 对象没有在任何地方被引用；

满足上述条件后“可以”进行回收，但“不一定”进行回收。

## 垃圾回收算法

### 标记-清除法

标记和清除的效率都不高，清除后产生大量不连续的内存块。

### 复制算法

划分内存，一块用完后把存活的对象复制到另一块空间，然后这一块全部清理。

由于新生代中的绝大部分对象生命周期很短，所以进行有针对性的内存划分。将内存分为较大的 Eden 和两块较小的 Survivor。每次使用 Eden 和其中一个 Survivor。当回收时，将 Eden 和 Survivor 中存活的对象复制到另一个 Survivor 中，然后清理 Eden 和原来的 Survivor。

### 标记-整理法

此算法针对老年代对象存活率较高的特点，在标记后将存活对象向内存一端移动，然后清除边界以外的空间。这样复制操作较少，也不需要额外的预留空间。

### 分代收集算法

把 Java 堆分为新生代和老年代。新生代用复制算法，老年代用标记-清除或标记-整理。

# 虚拟机执行子系统

## Class 类文件结构

Class 文件中只有两种数据类型：4 种长度的无符号数（u1、u2、u4、u8）、表。

| 类型           | 名称                | 数量             |
| -------------- | ------------------- | ---------------- |
| u4             | magic               | 1                |
| u2             | minor_version       | 1                |
| u2             | major_version       | 1                |
| u2             | constant_pool_count | 1                |
| cp_info        | constant_pool       | constant_pool-1  |
| u2             | access_flags        | 1                |
| u2             | this_class          | 1                |
| u2             | super_class         | 1                |
| u2             | interfaces_count    | 1                |
| u2             | interfaces          | interfaces_count |
| u2             | fields_count        | 1                |
| field_info     | fields              | fields_count     |
| u2             | methods_count       | 1                |
| method_info    | methods             | methods_count    |
| u2             | attributes_count    | 1                |
| attribute_info | attributes          | attributes_count |

其中，magic	是各种文件普遍用来识别文件格式的一种方式。.java 文件的魔数是 0xCAFEBABE。

# 虚拟机类加载机制

## 类加载的时机

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

# Java 内存模型与线程

## Java 与线程

### 线程的实现

**内核线程 **Kernel-Level Thread，KLT

直接由操作系统支持的线程，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各处理器上。

**轻量级线程** Light Weight Process, LWP

通常意义上的线程。每个轻量级线程由一个内核线程支持。轻量级线程享受从内核线程带来的系统调度，但同时也增加了内核态和用户态之间切换的消耗，以及一定内核资源的消耗。

**用户线程** User Thread, UT

广义上讲，非内核线程的都算用户线程。狭义上讲，用户线程完全建立在用户线程库上，线程的生命周期完全在用户态中完成，不消耗额外的内核资源。

### 状态转换

Java 定义了 5 种线程状态。

- 新建 new：创建后尚未启动。
- 运行 runable：正在执行或等待分配 CPU 时间。
- 无限期等待 waiting：不会分配到 CPU 时间，需要其他线程显式唤醒。
  - 没有设置 Timeout 参数的 Object.wait() 方法。
  - 没有设置 Timeout 参数的 Thread.join() 方法。
  - LockSupport.park() 方法。
- 限期等待 timed waiting：不会分配到 CPU 时间，通过自身自动唤醒。
  - Thread.sleep() 方法。
  - 设置了 Timeout 参数的 Object.wait() 方法。
  - 设置了 Timeout 参数的 Thread.join() 方法。
  - LockSupport.parkNanos() 方法。
  - LockSupport.parkUntil() 方法。
- 阻塞 blocked：在等待获取一个排他锁。
- 结束 terminated：线程终止。
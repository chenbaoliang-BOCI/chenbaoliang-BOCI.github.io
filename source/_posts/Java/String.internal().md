---
title: String.internal()
date: 2017-01-01 09:00:00
tags: [Java]
---

# intern 方法

> 返回字符串对象的规范化表示形式。
>     
> 一个初始时为空的字符串池，它由类 String 私有地维护。
>     
> 当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 `equals(Object)` 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。
>     
> 它遵循对于任何两个字符串 s 和 t，当且仅当 `s.equals(t)` 为 true 时，`s.intern() == t.intern()` 才为 true。
>     
> 所有字面值字符串和字符串赋值常量表达式都是内部的。
>     
> 返回：
>     
> 一个字符串，内容与此字符串相同，但它保证来自字符串池中。

# intern 方法的功能

JVM 中，字符串引用存于栈中并指向字符串对象，而字符串对象存于两个地方：堆和常量池。其中，JDK1.7 之前，常量池位于方法区中；JDK1.7 开始，常量池位于堆中。

当声明静态字符串时，如：`"ab"`、`"a"+"b"`，会先在字符串池中查找，若无则添加至池中（详见下一节），然后返回池中相应字符串的引用（实际上 `"a"+"b"` 会被编译器简化为 `"ab"`）。
当用 `new String()` 或含有变量的拼接字符串进行声明时，如 `new String("a")+new String("b")`、`"a"+b`，字符串 "ab" 不会进入字符串池。
当用 `new String()` 进行声明，且用字符串常量作为构造参数时，会在常量池和堆中生成两个字符串对象。例如：`new String("a")`。

# intern 方法的变化

JDK1.7 之前和之后的 intern 方法的具体实现有所不同。

- 之前：若常量池中已有该字符串，则返回该对象的引用；若常量池中无该字符串，则**在常量池中生成该字符串对象**，再将引用指向它。
- 之后：若常量池中已有该字符串，则返回该对象的引用；若常量池中无该字符串，则**在常量池中存入一个引用，该引用指向堆中的原始的字符串对象**。

intern 方法本身是为了节约字符串占用的内存而存在的，从这一点来说，JDK1.7 的改动进一步优化了内存占用。
但是很多人还会把该方法作另一用途，即直接用 `==` 来判断两个字符串是否相等。JDK1.7 的改动导致这种用途的结果有时会跟之前版本的不同，比如：
```
String s = new String("a") + new String("b");//堆中生成 "ab"
s.intern();//常量池中生成一个引用，指向堆中 "ab" 对象
String t = "ab";//指向常量池中的内容，根据 JDK 的不同可能是一个引用，也可能是一个对象
System.out.println(s == t);
```
在 JDK1.7 之前，结果是 false。因为 s 指向一个堆中的对象，t 指向一个常量池中的对象（该对象由 `s.intern()` 生成）。
在 JDK1.7 之后，结果是 true。因为 s 指向一个堆中的对象，`s.intern()` 在常量池中生成了一个引用，指向堆中的字符串。然后 t 使用了常量池中的引用，从而也指向堆中的字符串。

# intern 方法的实现和限制

String.intern 方法的大致实现方式是通过 JNI 调用由 C++ 实现的 StringTable 的 intern 方法，其数据结构类似 HashMap，但大小固定，默认为 1009。

若 StringTable 的空间太小，则会出现大量的 hash 碰撞，进而导致花费大量的时间在某个 hash 值对应的链表中查找指定的字符串。

JDK1.7 开始可以通过 `-XX:StringTableSize=60013` 来指定 StringTable 的大小。其中指定的数字最好是一个适当大小的质数，这样可以尽可能地避免因为代码中生成的字符串带有潜在的规律性而导致 hash 值集中在一系列呈周期间隔的值附近，即尽可能避免 hash 碰撞。

在一些底层方法中若频繁使用字符串，则使用 intern 方法可以有效的提升性能。但需要谨慎评估可能使用的不同内容的字符串数量。若数量极大或难以预估，就必须在代码中加入一个阈值，该阈值须明显低于常量池大小（考虑到程序的其他地方也要用到常量池）。仅当已生成的不同内容的字符串数量低于该阈值时才使用 intern 方法。

# 结论

1. **不要依赖 intern 方法来进行字符串相等的判断**，这样做很容易出错，而且让其他不熟悉这块原理的人难以维护代码。
2. **不必刻意使用 intern 方法来节省字符串占用的堆空间**。因为若字符串对象较少，则性能提升不大，却增加了维护成本；若**不同内容**的字符串极多，则因为常量池本身有容量上限，会导致性能急剧下降，得不偿失。唯一可以考虑使用 intern 方法的场景是，会生成大量字符串对象，而且确定这些字符串的内容范围不会太大，这样实际上是通过增加一点点调用 intern 方法的时间，来节省大量 gc 的时间。
